---
title: Lifecycle and Persistence
description: How Sprites hibernate, wake, and persist data
---

import LifecycleDiagram from '@/components/LifecycleDiagram.astro';
import { Callout, LinkCard, CardGrid } from '@/components/react';

Sprites hibernate when idle and wake on demand. Your files persist across sessions. You only pay for compute while actively working.

## How it works

A Sprite starts in a `cold` state. When you run a command or connect to it, the Sprite wakes and transitions to `running`. After 30 seconds of inactivity, it hibernates back to `cold`. (You may see a `warm` state when listing Sprites. This is a brief suspended state before full hibernation. You don't need to manage it.)

A Sprite is considered active when:

- A command is executing
- A TTY session is open
- A detachable session is running
- There's an active TCP connection to the Sprite's URL

When none of these are true, the 30-second idle timer starts. Once it expires, the Sprite hibernates. Compute billing stops immediately.

{/* <LifecycleDiagram /> */}

## Waking up

Sprites wake automatically when you interact with them: CLI, API, or HTTP request. Wake time is typically a few seconds. The request blocks until the Sprite is ready.

Disk state is preserved. Running processes are not.

## Persistence

Every Sprite has an ext4 filesystem backed by a two-tier storage system:

- **Hot storage**: NVMe cache for active data while the Sprite is running
- **Cold storage**: Object storage where all data persists

When you write files, they go to the fast NVMe cache. The filesystem syncs data to object storage automatically. When the Sprite hibernates, your data lives in cold storage. On wake, it's available again with the same paths and data.

You don't need to manage this. It looks and feels like a normal Linux filesystem. Since it's real ext4 (not NFS or FUSE), you won't hit weird edge cases. Shared memory files work. SQLite works in all its modes.

### Capacity

You start with 100 GB. Storage grows automatically as needed.

### What persists

| Persisted | Not persisted |
|-----------|---------------|
| All files and directories | Running processes |
| Installed packages | In-memory state |
| Git repositories | Network connections |
| Databases (SQLite, etc.) | `/tmp` contents |

### Billing

You pay for actual bytes stored, not allocated space. Storage is TRIM-friendly, so your bill goes down when you delete files.

- **Hot storage**: Sampled every few seconds while the Sprite is running. 2 GB cached for 4 hours = 8 GB-hours.
- **Cold storage**: Measured hourly. 10 GB stored for 24 hours = 240 GB-hours.

{/* See [Billing](/reference/billing) for rates. */}

## Resources

Each Sprite runs with:

- **8 vCPUs**
- **4 GB RAM**
- **100 GB storage** (grows automatically)

Compute is fixed. One size keeps things simple.

## Tips

**Let it sleep.** Sprites hibernate for a reason. Don't fight the lifecycle unless you have a specific need for low-latency wake times.

**Use file-based storage.** SQLite, flat files, and Git repos persist automatically. You don't need external databases for most use cases.

**Keep sessions detachable.** Long-running work should use detachable sessions so it survives disconnects and hibernation.

**Clean up before idle.** Flush writes and close files cleanly. The filesystem handles this well, but it's good practice.

{/* ## Related

<CardGrid client:load>
  <LinkCard
    href="/concepts/services"
    title="Services"
    description="Persistent processes that restart on wake"
    icon="cog"
    client:load
  />
  <LinkCard
    href="/concepts/checkpoints"
    title="Checkpoints"
    description="Save and restore Sprite state"
    icon="folder"
    client:load
  />
  <LinkCard
    href="/reference/billing"
    title="Billing"
    description="Pricing and cost optimization"
    icon="file-text"
    client:load
  />
  <LinkCard
    href="/concepts/networking"
    title="Networking"
    description="HTTP access, URLs, and port forwarding"
    icon="globe"
    client:load
  />
</CardGrid> */}
