---
title: Checkpoints
description: Save and restore Sprite state with checkpoints
draft: true
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Snippet, LinkCard, CardGrid, Callout } from '@/components/react';

**Checkpoints let you save a Sprite's entire state and restore it later.** They capture your filesystem, installed packages, environment config, and dotfilesâ€”but not running processes, network connections, or anything in memory.

Checkpoints are fast to create (~300ms), safe to restore, and useful anywhere you'd want a clean slate or an undo button. Here's how they work and how to use them in your tooling.

## What is a Checkpoint?

A checkpoint is a snapshot of your Sprite's persistent state:

- **Filesystem** - all files, directories, and data
- **Installed packages** - system and language-specific
- **Configuration** - environment setup and dotfiles
- **Services and policies** - any you've configured

The Sprite keeps running while the snapshot is taken, so you can keep working.

Checkpoints don't capture running processes, network connections, or anything in memory. Services need to be restarted after a restore.

Under the hood, checkpoints use copy-on-write storage, meaning only changed blocks get saved. This keeps them fast and space-efficient.

## Creating a Checkpoint

You can create a checkpoint with a single CLI command:

```bash
sprite checkpoint create --comment "Clean Python 3.11 + Node 20 setup"
```

```output
Checkpoint created: v1
```

The `--comment` flag is optional but helps you remember what each checkpoint is for.

If you're automating in code, the Go, JavaScript, and Elixir SDKs support streaming progress. You'll get real-time updates as the checkpoint is built.

<Tabs>
<TabItem label="Go">
```go
stream, err := sprite.CreateCheckpointWithComment(ctx, "my checkpoint")
if err != nil {
    log.Fatal(err)
}

err = stream.ProcessAll(func(msg *sprites.StreamMessage) error {
    fmt.Printf("%s: %s\n", msg.Type, msg.Data)
    return nil
})
if err != nil {
    log.Fatal(err)
}
```
</TabItem>
<TabItem label="JavaScript">
```javascript
const stream = await sprite.createCheckpoint("my checkpoint");

for await (const msg of stream) {
  console.log(`${msg.type}: ${msg.data}`);
}
```
</TabItem>
<TabItem label="Elixir">
```elixir
{:ok, messages} = Sprites.create_checkpoint(sprite, comment: "my checkpoint")

Enum.each(messages, fn msg ->
  IO.puts("#{msg.type}: #{msg.data}")
end)
```
</TabItem>
</Tabs>

## Restoring from a Checkpoint

Restoring replaces your Sprite's filesystem with the saved snapshot. Running processes are stopped, and the environment restarts with the restored state.

<Tabs>
<TabItem label="CLI">
```bash
sprite checkpoint restore v1
```
</TabItem>
<TabItem label="Go">
```go
stream, err := sprite.RestoreCheckpoint(ctx, "v1")
if err != nil {
    log.Fatal(err)
}

err = stream.ProcessAll(func(msg *sprites.StreamMessage) error {
    fmt.Printf("%s: %s\n", msg.Type, msg.Data)
    return nil
})
if err != nil {
    log.Fatal(err)
}
```
</TabItem>
<TabItem label="JavaScript">
```javascript
const stream = await sprite.restoreCheckpoint("v1");

for await (const msg of stream) {
  console.log(`${msg.type}: ${msg.data}`);
}
```
</TabItem>
<TabItem label="Elixir">
```elixir
{:ok, messages} = Sprites.restore_checkpoint(sprite, "v1")

Enum.each(messages, fn msg ->
  IO.puts("#{msg.type}: #{msg.data}")
end)
```
</TabItem>
</Tabs>

### Restore Considerations

- **Fast** - typically under a second
- **Destructive** - current state is replaced (but backed up automatically)
- **Processes stop** - you'll need to restart any services
- **CLI retry** - `sprite exec` commands automatically retry if the Sprite is still restarting

## Managing Checkpoints

### List Checkpoints

<Tabs>
<TabItem label="CLI">
```bash
sprite checkpoint list
```

```output
ID    CREATED              COMMENT
v1    2024-01-15 10:30:00  After npm install
v0    2024-01-14 15:45:00  Base (clean) state
```
</TabItem>
<TabItem label="Go">
```go
checkpoints, err := sprite.ListCheckpoints(ctx, "")
if err != nil {
    log.Fatal(err)
}

for _, cp := range checkpoints {
    fmt.Printf("%s  %s  %s\n", cp.ID, cp.CreateTime.Format(time.RFC3339), cp.Comment)
}
```
</TabItem>
<TabItem label="JavaScript">
```javascript
const checkpoints = await sprite.listCheckpoints();

for (const cp of checkpoints) {
  console.log(`${cp.id}  ${cp.createTime.toISOString()}  ${cp.comment}`);
}
```
</TabItem>
<TabItem label="Elixir">
```elixir
{:ok, checkpoints} = Sprites.list_checkpoints(sprite)

for cp <- checkpoints do
  IO.puts("#{cp.id}  #{cp.create_time}  #{cp.comment}")
end
```
</TabItem>
</Tabs>

### Get Checkpoint Details

<Tabs>
<TabItem label="CLI">
```bash
sprite checkpoint info v1
```

```output
ID: v1
Created: 2024-01-15T10:30:00Z
Comment: After npm install
```
</TabItem>
<TabItem label="Go">
```go
cp, err := sprite.GetCheckpoint(ctx, "v1")
if err != nil {
    log.Fatal(err)
}

fmt.Printf("ID: %s\n", cp.ID)
fmt.Printf("Created: %s\n", cp.CreateTime.Format(time.RFC3339))
fmt.Printf("Comment: %s\n", cp.Comment)
```
</TabItem>
<TabItem label="JavaScript">
```javascript
const cp = await sprite.getCheckpoint("v1");

console.log(`ID: ${cp.id}`);
console.log(`Created: ${cp.createTime.toISOString()}`);
console.log(`Comment: ${cp.comment}`);
```
</TabItem>
<TabItem label="Elixir">
```elixir
{:ok, cp} = Sprites.get_checkpoint(sprite, "v1")

IO.puts("ID: #{cp.id}")
IO.puts("Created: #{cp.create_time}")
IO.puts("Comment: #{cp.comment}")
```
</TabItem>
</Tabs>

### Delete a Checkpoint

<Tabs>
<TabItem label="CLI">
```bash
sprite checkpoint delete v3
```

```output
Deleted
```
</TabItem>
</Tabs>

<Callout type="warning" title="You can't delete the active checkpoint" client:load>
Restore to a different checkpoint first, then delete the original.
</Callout>

Deleted checkpoints can't be recovered. A few things to keep in mind:

- **Billing stops immediately** once the checkpoint is deleted
- **Keep at least one stable checkpoint** as a known-good fallback
- **Review old checkpoints periodically** to manage storage costs

## Checkpointing from Inside a Sprite

You can create and restore checkpoints from within the Sprite itself. This is useful for automation, error recovery, and self-managing agents.

### Using sprite-env

```bash
sprite-env checkpoints list
sprite-env checkpoints create
sprite-env checkpoints restore v1
```

### Direct API Access

```bash
# List checkpoints
curl --unix-socket /.sprite/api.sock \
  -H "Content-Type: application/json" \
  http://sprite/v1/checkpoints

# Create checkpoint
curl --unix-socket /.sprite/api.sock \
  -H "Content-Type: application/json" \
  -X POST http://sprite/v1/checkpoint
```

Both methods stream NDJSON progress:

```json
{"type": "info", "data": "Creating checkpoint..."}
{"type": "complete", "data": "Checkpoint v3 created"}
```

### Restore Behavior

The restore request returns HTTP 202 immediately since the Sprite restarts during the operation. The connection closes, and subsequent commands retry automatically.

### Self-Checkpointing Agents

Point your LLM at `/.sprite/llm.txt` to help it understand the environment, then it can use `sprite-env` to checkpoint before risky operations:

```bash
sprite-env checkpoints create
rm -rf node_modules && npm install

# If things go wrong
sprite-env checkpoints restore v4
```



## Checkpoint Storage

Checkpoints are stored using [Tigris Standard tier](https://www.tigrisdata.com/docs/objects/tiers/#standard-tier):

- **Geographically redundant** - data replicated across regions
- **Highly durable** - designed for frequently accessed data
- **Compressed** - efficient storage usage

### Storage Costs

Checkpoints are billed at $0.50/GB/month. Because of copy-on-write, incremental checkpoints only store changed blocks. See [Billing](/reference/billing) for details.

### Browsing Checkpoints

The last 5 checkpoints are mounted read-only at `/.sprite/checkpoints/` inside your Sprite, so you can browse or diff previous states without restoring.

## Common Patterns

Checkpoints make it easier to standardize environments, test changes safely, and recover quickly when things break.

### Environment Templates

Use a checkpoint as a clean baseline for new projects or teammates:

```bash
sprite create gold-standard
sprite exec "install-base-tools.sh"
sprite exec "configure-defaults.sh"
sprite checkpoint create --comment "Gold standard v1.0"

# Start a new project from the same base
sprite use gold-standard
sprite checkpoint restore v1
```

### Automated Checkpointing in Scripts

Create a checkpoint before deployments so you can roll back if something fails:

```bash
#!/bin/bash
sprite checkpoint create --comment "Pre-deploy $(date +%Y%m%d-%H%M)"

if ! sprite exec "deploy.sh"; then
  echo "Deployment failed, rolling back..."
  sprite checkpoint restore v1
  exit 1
fi

echo "Deployment successful"
```

### A/B Testing Configurations

Fan out from a common base to create multiple test environments:

```bash
sprite use base-config
sprite exec "setup-base.sh"
sprite checkpoint create --comment "Base config for A/B test"

# Create variant A
sprite create variant-a
sprite checkpoint restore v1
sprite exec "apply-config-a.sh"

# Create variant B
sprite create variant-b
sprite checkpoint restore v1
sprite exec "apply-config-b.sh"

# Run tests in parallel
sprite use variant-a && sprite exec "run-tests.sh" &
sprite use variant-b && sprite exec "run-tests.sh" &
wait
```

## Checkpoint Tips

### Use Comments

Checkpoints use sequential version IDs (v0, v1, v2...), so comments help you remember what each one is for:

```bash
sprite checkpoint create --comment "Clean Python 3.11 + Node 20 setup"
```

### When to Checkpoint

- Before upgrades, refactors, or experiments
- After milestones (tests pass, feature complete)
- Daily during active development

### Clean Up Old Checkpoints

Checkpoints take up space. Delete the ones you don't need:

```bash
sprite checkpoint list
sprite checkpoint delete v1
```

See [Delete a Checkpoint](#delete-a-checkpoint) for details.

### Use Git for Code

Checkpoints capture environment state, not version history. Use checkpoints for setup, config, and temporary state. Use Git for code.

```bash
sprite exec "git commit -am 'Save progress'"
sprite checkpoint create
```

## Related Documentation

<CardGrid client:load>
  <LinkCard
    href="/concepts/lifecycle"
    title="Lifecycle and Persistence"
    description="Understanding how persistence works"
    icon="layers"
    client:load
  />
  <LinkCard
    href="/cli/commands"
    title="CLI Commands"
    description="Checkpoint and other CLI commands"
    icon="terminal"
    client:load
  />
  <LinkCard
    href="/reference/billing"
    title="Billing"
    description="Storage costs and pricing details"
    icon="file-text"
    client:load
  />
  <LinkCard
    href="/concepts/services"
    title="Services"
    description="Long-running processes that persist across reboots"
    icon="cog"
    client:load
  />
</CardGrid>
