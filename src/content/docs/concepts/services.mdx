---
title: Services
description: Long-running processes that persist across Sprite reboots
---

import { LinkCard, CardGrid } from '@/components/react';

Services are long-running background processes that persist even after your Sprite reboots. They're for anything you want to keep running: databases, dev servers, background workers, reverse proxies.

If you've used detachable sessions, you know they're useful for one-off or interactive tasks. But sessions don't survive a full Sprite restart. Services do. They're managed by the Sprite runtime, start automatically on boot, and restart on failure.

You interact with them through an internal API, or more conveniently, with the `sprite-env` CLI. You define a service with a command, some arguments, and optionally a list of dependencies. Sprite takes care of the rest.

## Creating and Managing Services

You create a service with a simple HTTP PUT request to the internal Sprite API, or by using `sprite-env curl`:

The required field is `cmd`, which should point to the executable. You can also pass `args`, and if your service depends on others, list them under `needs`:

```bash
# Simple service
sprite-env curl -X PUT /v1/services/myapp -d '{
  "cmd": "/usr/bin/myapp",
  "args": ["--port", "8080"]
}'

# Service with dependencies
sprite-env curl -X PUT /v1/services/webapp -d '{
  "cmd": "npm",
  "args": ["run", "dev"],
  "needs": ["database"]
}'
```

Services are defined declaratively. Once created, they start immediately and are automatically restarted on reboot or failure.

### Streaming Logs

By default, the API streams logs for 5 seconds after a service is created. You can change this by setting the `duration` query param:

```bash
# Stream logs for 10 seconds after creation
sprite-env curl -X PUT '/v1/services/myapp?duration=10s' -d '{
  "cmd": "npm",
  "args": ["run", "dev"]
}'
```

Omit the `duration` parameter or set a short value like `duration=1s` if you don't need extended log streaming.

### Managing Services

Use the CLI to list, inspect, or delete services:

```bash
# List all services
sprite-env services list

# Get detailed state
sprite-env services get myapp

# Delete a service
sprite-env services delete myapp
```

Each service has a state that includes status, PID, and start time:

```json
{
  "name": "webapp",
  "cmd": "npm",
  "args": ["start"],
  "needs": ["postgres"],
  "state": {
    "status": "running",
    "pid": 1234,
    "started_at": "2024-01-15T10:30:00Z"
  }
}
```

### Send Signals

Send Unix signals to a service:

```bash
# Graceful shutdown
sprite-env curl -X POST /v1/services/signal -d '{
  "name": "webapp",
  "signal": "TERM"
}'

# Reload configuration (for services that support it)
sprite-env curl -X POST /v1/services/signal -d '{
  "name": "nginx",
  "signal": "HUP"
}'
```
Services that exit will be restarted automatically. That's the whole point.

### Service Configuration

| Field | Type | Description |
|-------|------|-------------|
| `cmd` | string | Path to executable (required) |
| `args` | string[] | Command-line arguments |
| `needs` | string[] | Services that must start first |

## Services vs Detachable Sessions

Both services and detachable sessions let you run long-lived processes inside a Sprite. The difference is what happens when your Sprite shuts down.

| Feature                    | Services           | Detachable Sessions     |
|----------------------------|--------------------|--------------------------|
| Survives Sprite restart    | ✅ Yes              | ❌ No                    |
| Auto-starts on boot        | ✅ Yes              | ❌ No                    |
| Managed via                | Internal API       | External CLI or SDK     |
| Dependencies (`needs`)     | ✅ Supported        | ❌ Not supported         |
| Use case                   | Always-on daemons  | One-off tasks, builds    |

Use a **service** when something should run continuously. That might be a dev server, a background worker, or a local database.

Use a **session** for one-off commands, interactive shells, or build scripts you want to monitor or reconnect to. Sessions are easier to experiment with. Services are more durable.

## Common Patterns

Here are a few real-world cases where services are a better fit than sessions.

### Dev Server That Should Always Be Running

```bash
sprite-env curl -X PUT /v1/services/devserver -d '{
  "cmd": "npm",
  "args": ["run", "dev"]
}'

```

Your dev environment lives here now. No need to restart it every time your Sprite boots.

### Database with Dependent Service

```bash
# First, create the database service
sprite-env curl -X PUT /v1/services/postgres -d '{
  "cmd": "/usr/lib/postgresql/16/bin/postgres",
  "args": ["-D", "/home/sprite/pgdata"]
}'

# Then create a service that depends on it
sprite-env curl -X PUT /v1/services/webapp -d '{
  "cmd": "npm",
  "args": ["start"],
  "needs": ["postgres"]
}'
```

`needs` ensures your services come up in the right order. Sprite won't start `webapp` until `postgres` is running.

### Python Background Worker

If your app pushes jobs to a queue, the worker can just sit in the background chewing through them. No babysitting required.

```bash
sprite-env curl -X PUT /v1/services/worker -d '{
  "cmd": "python",
  "args": ["-m", "celery", "worker", "-A", "tasks"]
}'
```

## LLM Integration

If you're building an AI coding agent—or just letting one loose on your Sprite—it can manage services too. The internal API works fine for programmatic control.

Start by pointing the agent at /.sprite/llm.txt for a description of the environment. From there, it can create services, check status, and restart things when needed:

```bash
# LLM creates a service for the project it's working on
sprite-env curl -X PUT /v1/services/devserver -d '{
  "cmd": "/bin/sh",
  "args": ["-c", "npm run dev"]
}'

# Check if it's running
sprite-env services get devserver

# Restart after making changes
sprite-env curl -X POST /v1/services/signal -d '{"name": "devserver", "signal": "TERM"}'
# Service auto-restarts
```

The service restarts automatically. You don't need to script it.

## Troubleshooting

**My service won't start**

- Make sure the command path is correct and executable
- Check that the working directory exists
- If using `needs`, make sure dependencies are running

**My service keeps restarting**

- It probably crashed. Try streaming logs with `duration=30s`
- Double-check environment variables
- Test the command manually to reproduce the issue

**How do I see logs?**

- Stream them during creation:

  ```bash
  sprite-env curl -X PUT '/v1/services/myapp?duration=60s' -d '{...}'
  ```

## Related Documentation

<CardGrid client:load>
  <LinkCard
    href="/concepts/lifecycle"
    title="Lifecycle and Persistence"
    description="Understanding sprite hibernation and state management"
    icon="layers"
    client:load
  />
  <LinkCard
    href="/concepts/checkpoints"
    title="Checkpoints"
    description="Save and restore sprite state with checkpoints"
    icon="folder"
    client:load
  />
  <LinkCard
    href="/reference/base-images"
    title="Base Images"
    description="Pre-installed tools and available images"
    icon="terminal"
    client:load
  />
  <LinkCard
    href="/cli/commands"
    title="CLI Commands"
    description="Service management commands"
    icon="terminal"
    client:load
  />
</CardGrid>
