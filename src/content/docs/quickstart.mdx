---
title: Quickstart
description: Get up and running with Sprites in 5 minutes
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Callout, LinkCard, CardGrid } from '@/components/react';

Think of a Sprite as your personal computer in the cloud—but better. Unlike containers that start from scratch each time, **Sprites are persistent VMs that wake up on demand**. Install dependencies once, clone repos, create files—everything stays exactly where you left it. When you're not using it, your Sprite goes to sleep. When you send a command or HTTP request, it wakes up instantly.

This guide will walk you through creating your first Sprite. In just a few minutes, you'll have a persistent development environment that responds to HTTP traffic and remembers everything between runs.

## Install the CLI

Install with our install script (macOS/Linux):

```bash
curl -fsSL https://sprites.dev/install.sh | sh
```

This auto-detects your platform, downloads the binary with checksum verification, and installs to `~/.local/bin`.

For Windows or manual installation, see [CLI Installation](/cli/installation) or download from [GitHub Releases](https://github.com/superfly/sprite-env/releases).

Verify installation:

```bash
sprite --help
```

## Authenticate

Sprites uses your Fly.io account for authentication:

```bash
sprite org auth
```

This opens a browser window to authenticate with Fly.io.

<Callout type="info">
If authentication fails, try running `fly auth logout` followed by `fly auth login` first, then retry `sprite org auth`.
</Callout>

## Create Your First Sprite

```bash
sprite create my-first-sprite
```

This creates a new Sprite with default configuration, running and ready to accept commands.

Set it as your active Sprite to avoid adding `-s my-first-sprite` to every command:

```bash
sprite use my-first-sprite
```

## Run Commands

Execute commands in your Sprite:

```bash
# Run a simple command
sprite exec echo "Hello, Sprites!"

# Run multiple commands
sprite exec "cd /tmp && ls -la"

# Open an interactive shell
sprite console
```

## See Persistence in Action

Your Sprite comes pre-configured with common development tools (Node.js, Python, Go, Git, and more). Here's the magic: **everything you install or create persists between commands**.

```bash
# Check available runtimes
sprite exec "node --version && python3 --version && go version"

# Install a Python package
sprite exec "pip install requests"

# Create a file
sprite exec "echo 'Hello from my persistent Sprite!' > /home/sprite/greeting.txt"

# Disconnect, get coffee, come back later...
# Everything is still there!
sprite exec "cat /home/sprite/greeting.txt"
sprite exec "python -c 'import requests; print(requests.__version__)'"
```

Unlike containers that reset on each run, your Sprite keeps your installed packages, files, and entire filesystem intact.

## Start a Web Server

Every Sprite has a unique HTTP URL and can serve traffic. Let's see it in action by starting a simple Python server:

```bash
# Start a simple HTTP server on port 8080
sprite exec "python -m http.server 8080 &"

# Get your Sprite's public URL
sprite url
```

Now visit the URL in your browser—you'll see Python's directory listing page. Your Sprite automatically routes HTTP traffic to port 8080 and wakes up to handle requests.

Try this: close your terminal, wait a minute, then visit the URL again. Your Sprite wakes up automatically to serve the request. That's the magic of on-demand wakeup.

<Callout type="tip">
**Managing Sprites**: Use `sprite list` to see all your Sprites, or `sprite destroy my-first-sprite` when you're done with one. You can have multiple Sprites running simultaneously—each with its own isolated environment.
</Callout>

<Callout type="success">
**You've got a working Sprite!** You've created a persistent environment, installed packages, created files, and served HTTP traffic—all of which will be there next time you connect. Everything from here is optional, but worth exploring when you're ready.
</Callout>

---

## Using the SDKs

The CLI is perfect for day-to-day development, but if you're building tools, automations, or integrating Sprites into your application, the SDKs give you programmatic control. Use them to dynamically create environments, orchestrate workloads, or embed Sprites into your product.

<Tabs>
<TabItem label="JavaScript">
```javascript
import { SpritesClient } from '@fly/sprites';

const client = new SpritesClient(process.env.SPRITE_TOKEN);

const sprite = await client.createSprite('my-sprite');

// Execute a command
const result = await sprite.execFile('python', ['-c', "print('hello')"]);
console.log(result.stdout);

// Stream output from long-running commands
const cmd = sprite.spawn('bash', ['-c', 'for i in {1..10}; do date +%T; sleep 0.5; done']);
for await (const line of cmd.stdout) {
  process.stdout.write(line);
}

await sprite.delete();
```
</TabItem>

<TabItem label="Go">
```go
package main

import (
    "context"
    "fmt"
    "io"
    "os"

    sprites "github.com/superfly/sprites-go"
)

func main() {
    ctx := context.Background()
    client := sprites.New(os.Getenv("SPRITE_TOKEN"))

    sprite, _ := client.CreateSprite(ctx, "my-sprite", nil)
    defer client.DeleteSprite(ctx, "my-sprite")

    // Execute a command
    cmd := sprite.Command("python", "-c", "print('hello')")
    output, _ := cmd.Output()
    fmt.Println(string(output))

    // Stream output from long-running commands
    cmd = sprite.Command("bash", "-c", "for i in {1..10}; do date +%T; sleep 0.5; done")
    stdout, _ := cmd.StdoutPipe()
    cmd.Start()
    io.Copy(os.Stdout, stdout)
    cmd.Wait()
}
```
</TabItem>

<TabItem label="Elixir">
```elixir
client = Sprites.new(System.get_env("SPRITE_TOKEN"))

{:ok, sprite} = Sprites.create(client, "my-sprite")

# Execute a command
{output, 0} = Sprites.cmd(sprite, "python", ["-c", "print('hello')"])
IO.puts(output)

# Stream output from long-running commands
sprite
|> Sprites.stream("bash", ["-c", "for i in {1..10}; do date +%T; sleep 0.5; done"])
|> Stream.each(&IO.write/1)
|> Stream.run()

Sprites.destroy(sprite)
```
</TabItem>
</Tabs>

---

## Next Steps

<CardGrid client:load>
  <LinkCard
    href="/working-with-sprites"
    title="Working with Sprites"
    description="Sessions, ports, persistence, and everything beyond the basics"
    icon="book-open"
    client:load
  />
  <LinkCard
    href="/cli/commands"
    title="CLI Reference"
    description="Complete command-line documentation"
    icon="terminal"
    client:load
  />
</CardGrid>

